%% This function plots interactive coronal/axial/sagittal slices for a T1 nifti image, and overlays electrodes from an electrodes.tsv file.
% Electrodes are plotted to each slice if they are within an adjustable distance from each slice
%
%   Requires the vox2pos matrix in the nifti (bmat) to not contain off-diagonal (rotational/shear) values. This is because this function does not perform
%   affine transformations and interpolations of the nifti volume. If off-diagonal values are present, error will be raised.
%
%   Dependency: Uses SPM12 functions to load the nifti
%
%   slicesGUI(niiPath, electrodes);
%   slicesGUI(niiPath, electrodes, optsIn);
%       niiPath =           char, path to nifti brain image, in ac-pc space. If not in ac-pc space, use the rest of the SEEG_view toolbox to generate AC-PC nifti.
%       electrodes =        char or n x 4+ table, path to electrodes table file (if given as char) or electrodes table. Must contain columns <name>, <x>, <y>, and <z>
%       optsIn =            (optional) struct, configurable options. Fields (not case-sensitive):
%           initialPos =    1x3 num, initial approximate [x, y, z] coordinate to plot at. Default = [0, 0, 0].
%                               The actual [x, y, z] coordinate plotted will be locked onto the closest slice positions.
%           elecDist =     num, Initial distance threshold for electrodes to be plotted. Electrodes are plotted to each slice if they are
%                               <elecDist distance away in the corresponding axis (x, y, or z). Set to inf for all electrodes plotted on all slices.
%                               Can be toggled by GUI buttons. Default = 8.
%           clim =          1x2 double, initial color limits for the MRI scaled intensity. Can be adjusted by GUI buttons. Default = [0, 1].
%                               If the T1 is generated by SEEG_view, the minimum voxel intensity = 0 and the 99%ile voxel intensity = 1.
%           crosshair =     char, 'on' or 'off', toggles initial crosshair visibility. Can then be toggled by GUI button. Default = true.
%           elecNames =     char, 'on' or 'off', toggles initial electrode name visibility (plotted over electrodes). Can then be toggled by GUI button. Default = false.
%           ms        =     num, marker size of plotted electrodes ('o' plot marker). Default = 5.
%           figSize   =     1x2 num, Initial dimensions [width, height] of figure. Default = [1600, 720].
%
%   Note that these configurable options allow GUI to be opened by the user in desired state and location, and automatically saved as image without interacting with GUI, if desired.
%
%   HH 2022/04
%   Updated with buttons and ability to click on any orientation: HH 2023/07
%
function handles = sliceGUI(niiPath, electrodes, optsIn)

    if ischar(electrodes) || isstring(electrodes)
        electrodes = readtable(electrodes, 'FileType', 'text', 'Delimiter', '\t', 'TreatAsEmpty', 'n/a');
    end
    
    % global constants
    global elecNameSz % font size for electrode names (replotted for new slices). Unlike ms, this is not an input opt bc it isn't used for final output

    % Configure opts
    opts.initialPos = [0, 0, 0];
    opts.elecDist = 8;
    opts.clim = [0, 1];
    opts.crosshair = 'on';
    opts.elecNames = 'off';
    opts.ms = 5; % edge color is now none so fewer parts in illutrator
    opts.figSize = [1600, 720];
    
    elecNameSz = 10;
       
    if exist('optsIn', 'var') && isa(optsIn, 'struct')
        inFields = fieldnames(optsIn);
        for ii = 1:length(inFields) % make case insensitive
            optsIn.(lower(inFields{ii})) = optsIn.(inFields{ii});
        end

        if isfield(optsIn, 'initialpos'), opts.initialPos = optsIn.initialpos; end
        if isfield(optsIn, 'clim'), opts.clim = optsIn.clim; end
        if isfield(optsIn, 'elecdist'), opts.elecDist = optsIn.elecdist; end
        if isfield(optsIn, 'crosshair'), opts.crosshair = optsIn.crosshair; end
        if isfield(optsIn, 'elecnames'), opts.elecNames = optsIn.elecnames; end
        if isfield(optsIn, 'ms'), opts.ms = optsIn.ms; end
        if isfield(optsIn, 'figsize'), opts.figSize = optsIn.figsize; end
    end

    img = spm_vol(niiPath);
    bvol = spm_read_vols(img); % load brain image
    bmat = img.mat; % vox -> pos transformation
    
    % Permute bvol and bmat so it follows columns x, y, z
    [~, index] = sortrows(abs(bmat(1:3, 1:3)'), [1, 2, 3], 'descend');
    bvol = permute(bvol, index);
    bmat = bmat(:, [index; 4]); % only rearrange first 3 columns
    
    bmatCheck = bmat(1:3, 1:3); % to check if there are any rotations/shears
    if ~all(bmatCheck(~eye(3)) == 0)
        disp(bmat);
        error('Error: vox2pos matrix has off-diagonal elements; slices are MISALIGNED from electrodes');
    end
    
    bvol = bvol/prctile(bvol(:), 99); % image intensity
    [bvol, bmat] = clipVol(bvol, bmat, 0.15); % remove empty space
    
    locs = [electrodes.x, electrodes.y, electrodes.z];
    
    [x, y, z] = getAxPos(bvol, bmat); % Get positions (mm) along x, y, z axes of brain volume. This may need updating if bmat dimensions are permuted
    
    % Find initial slice index/position at 0 corresponding to each orientation
    [~, yIdx] = min(abs(y - opts.initialPos(2))); % coronal
    ySlice = squeeze(bvol(:, yIdx, :));
    yValue = y(yIdx); % y value of coronal slice
    
    [~, zIdx] = min(abs(z - opts.initialPos(3))); % axial
    zSlice = squeeze(bvol(:, :, zIdx));
    zValue = z(zIdx); % z value of axial slice
    
    [~, xIdx] = min(abs(x - opts.initialPos(1))); % sagittal
    xSlice = squeeze(bvol(xIdx, :, :));
    xValue = x(xIdx); % x value of sagittal slice
    
    handles.f = figure('Position', [200, 100, opts.figSize(1), opts.figSize(2)]); % adequate for standard 1920 x 1080 monitor
    
    handles.f.UserData = opts; % use to pass to callback
    
    % keep track of current x,y,z values in handle, for tracking/diagnostic purposes and for the elecDist callback button
    handles.f.UserData.xValue = xValue;
    handles.f.UserData.yValue = yValue;
    handles.f.UserData.zValue = zValue;
    
    % Initialize axes: Each orientation slice, buttons, 0.02 gap between each button
    handles.axC = subplot('Position', [0.03, 0.25, 0.3, 0.7]); % coronal % 0.03 on L/R outer border, 0.02 between orientations
    handles.axA = subplot('Position', [0.35, 0.25, 0.3, 0.7]); % axial
    handles.axS = subplot('Position', [0.67, 0.25, 0.3, 0.7]); % sagittal
    handles.axCH = subplot('Position', [0.05, 0.05, 0.05, 0.1]); % crosshair button
    handles.axPN = subplot('Position', [0.12, 0.05, 0.05, 0.1]); % plotname button
    handles.axED = subplot('Position', [0.19, 0.05, 0.075, 0.1]); % elecdist button
    handles.axClim = subplot('Position', [0.285, 0.05, 0.075, 0.1]); % clim adjustment panel
    handles.axSave = subplot('Position', [0.9, 0.05, 0.05, 0.1]); % save button
    
    % CORONAL SLICE
    hold(handles.axC, 'on');
    
    % Plot MRI image
    imagesc(handles.axC, x, z, ySlice', 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, opts.clim); colormap(gray);

    % Plot electrodes and electrode names (Visibility off)
    locsC = locs(abs(locs(:, 2) - yValue) < opts.elecDist, :);
    namesC = electrodes.name(abs(locs(:, 2) - yValue) < opts.elecDist);    
    plot(handles.axC, locsC(:, 1), locsC(:, 3), 'o', 'Color', 'none', 'MarkerFaceColor', 'w', 'MarkerSize', opts.ms, 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes});
    text(handles.axC, locsC(:, 1), locsC(:, 3), namesC, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', opts.elecNames);
    
    % Plot crosshair (vertical then horizontal lines)
    plot(handles.axC, [xValue, xValue], [min(z), max(z)], 'r-', 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    plot(handles.axC, [min(x), max(x)], [zValue, zValue], 'r-', 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    
    % positional text
    text(handles.axC, min(x)+5, min(z)+10, sprintf('y=%.1f', yValue), 'color', 'w', 'FontSize', 14);
    
    set(handles.axC, 'XTick', [], 'YTick', [], 'YDir', 'normal', 'DataAspectRatio', [1, 1, 1], 'XLim', [min(x), max(x)], 'YLim', [min(z), max(z)]);
    hold(handles.axC, 'off');

    
    % AXIAL SLICE
    hold(handles.axA, 'on');
    
    % Plot MRI image
    imagesc(handles.axA, x, y, zSlice', 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, opts.clim); colormap(gray);

    % Plot electrodes and electrode names
    locsA = locs(abs(locs(:, 3) - zValue) < opts.elecDist, :);
    namesA = electrodes.name(abs(locs(:, 3) - zValue) < opts.elecDist);    
    plot(handles.axA, locsA(:, 1), locsA(:, 2), 'o', 'Color', 'none', 'MarkerFaceColor', 'w', 'MarkerSize', opts.ms, 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes});
    text(handles.axA, locsA(:, 1), locsA(:, 2), namesA, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', opts.elecNames);

    % Plot crosshair (vertical then horizontal lines)
    plot(handles.axA, [xValue, xValue], [min(y), max(y)], 'r-', 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    plot(handles.axA, [min(x), max(x)], [yValue, yValue], 'r-', 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    
    % positional text
    text(handles.axA, min(x)+5, min(y)+10, sprintf('z=%.1f', zValue), 'color', 'w', 'FontSize', 14);
    
    set(handles.axA, 'XTick', [], 'YTick', [], 'YDir', 'normal', 'DataAspectRatio', [1, 1, 1], 'XLim', [min(x), max(x)], 'YLim', [min(y), max(y)]);    
    hold(handles.axA, 'off');
    
    
    % SAGITTAL SLICE
    hold(handles.axS, 'on');
    
    % Plot MRI image
    imagesc(handles.axS, y, z, xSlice', 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, opts.clim); colormap(gray);

    % Plot electrodes and electrode names
    locsS = locs(abs(locs(:, 1) - xValue) < opts.elecDist, :);
    namesS = electrodes.name(abs(locs(:, 1) - xValue) < opts.elecDist);
    plot(handles.axS, locsS(:, 2), locsS(:, 3), 'o', 'Color', 'none', 'MarkerFaceColor', 'w', 'MarkerSize', opts.ms, 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes});
    text(handles.axS, locsS(:, 2), locsS(:, 3), namesS, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', opts.elecNames);
    
    % Plot crosshair (vertical then horizontal lines)
    plot(handles.axS, [yValue, yValue], [min(z), max(z)], 'r-', 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    plot(handles.axS, [min(y), max(y)], [zValue, zValue], 'r-', 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', opts.crosshair);
    
    % positional text
    text(handles.axS, min(y)+5, min(z)+10, sprintf('x=%.1f', xValue), 'color', 'w', 'FontSize', 14);
    
    set(handles.axS, 'XTick', [], 'YTick', [], 'YDir', 'normal', 'DataAspectRatio', [1, 1, 1], 'XLim', [min(y), max(y)], 'YLim', [min(z), max(z)]);
    hold(handles.axS, 'off');
    
    
    % plot crosshair button (on state to start)
    image(handles.axCH, getButtonCH(opts.crosshair), 'ButtonDownFcn', {@btnCallbackCH, handles});
    set(handles.axCH, 'XTick', [], 'YTick', []);
    
    % plot plotname button (off state to start)
    image(handles.axPN, getButtonPN(opts.elecNames), 'ButtonDownFcn', {@btnCallbackPN, handles});
    set(handles.axPN, 'XTick', [], 'YTick', []);
    
    % plot electrode distance button
    image(handles.axED, [0, 3], [0, 3], getEDBg); % static background
    hold(handles.axED, 'on');
    image(handles.axED, [2, 3], [0, 1], getButtonArrow('off', 'up'), 'ButtonDownFcn', {@btnCallbackED, handles, bvol, x, y, z, electrodes, 1}); % right side up, increase by 1 on click
    image(handles.axED, [2, 3], [2, 3], getButtonArrow('off', 'down'), 'ButtonDownFcn', {@btnCallbackED, handles, bvol, x, y, z, electrodes, -1}); % right side down, decrease by 1 on click
    hold(handles.axED, 'off')
    text(handles.axED, 2.5, 1.5, sprintf('%0.01f', opts.elecDist), 'HorizontalAlignment', 'Center', 'FontSize', 16); % display current electrode distance value
    
    % plot clim adjustment panel
    image(handles.axClim, [0, 3], [0, 3], getClimBg); % static background
    hold(handles.axClim, 'on');
    image(handles.axClim, [0, 1], [0, 1], getButtonArrow('off', 'up'), 'ButtonDownFcn', {@btnCallbackClim, handles, 1, 0.1}); % left side up
    image(handles.axClim, [0, 1], [2, 3], getButtonArrow('off', 'down'), 'ButtonDownFcn', {@btnCallbackClim, handles, 1, -0.1}); % left side down
    image(handles.axClim, [2, 3], [0, 1], getButtonArrow('off', 'up'), 'ButtonDownFcn', {@btnCallbackClim, handles, 2, 0.1}); % right side up
    image(handles.axClim, [2, 3], [2, 3], getButtonArrow('off', 'down'), 'ButtonDownFcn', {@btnCallbackClim, handles, 2, -0.1}); % right side down
    hold(handles.axClim, 'off');
    set(handles.axClim, 'XTick', [], 'YTick', []);
    text(handles.axClim, 0.5, 1.5, sprintf('%0.01f', opts.clim(1)), 'HorizontalAlignment', 'Center', 'FontSize', 16); % display current Clim values (left, right)
    text(handles.axClim, 2.5, 1.5, sprintf('%0.01f', opts.clim(2)), 'HorizontalAlignment', 'Center', 'FontSize', 16);
    
    % plot save button
    image(handles.axSave, getButtonSave('off'), 'ButtonDownFcn', {@btnCallbackSave, handles});
    set(handles.axSave, 'XTick', [], 'YTick', []);
    
    % turn off axes (borders) for buttons
    set([handles.axCH, handles.axPN, handles.axED, handles.axClim, handles.axSave], 'Visible', 'off');
    
end


%% Button callback functions

% coronal slice click
function btnCallbackC(~, ~, handles, bvol, x, y, z, electrodes)

    global elecNameSz

    locs = [electrodes.x, electrodes.y, electrodes.z];
    
    pt = get(gca, 'CurrentPoint');
    xCurr = pt(1, 1); zCurr = pt(1, 2); % get x and z coordinates that are clicked
    
    % Calculate nearest exact slice x, z coordinates
    [~, zIdx] = min(abs(z - zCurr));
    zSlice = squeeze(bvol(:, :, zIdx));
    zValue = z(zIdx);
    [~, xIdx] = min(abs(x - xCurr));
    xSlice = squeeze(bvol(xIdx, :, :));
    xValue = x(xIdx);
    
    
    % Coronal slice (change position of crosshair only)
    set(handles.axC.Children(3), 'XData', [xValue, xValue]); % vertical line
    set(handles.axC.Children(2), 'YData', [zValue, zValue]); % horizontal line
        
    
    % AXIAL
    % update MRI slice (last layer)
    set(handles.axA.Children(end), 'CData', zSlice');
    
    % update the electrode positions (second to last layer)
    locsA = locs(abs(locs(:, 3) - zValue) < handles.f.UserData.elecDist, :); % plot electrodes
    set(handles.axA.Children(end-1), 'XData', locsA(:, 1), 'YData', locsA(:, 2));
    
    % update electrode labels
    delete(handles.axA.Children(4:end-2)); % first delete the existing labels
    namesA = electrodes.name(abs(locs(:, 3) - zValue) < handles.f.UserData.elecDist);
    nElecs = length(namesA); % how many labels are plotted
    text(handles.axA, locsA(:, 1), locsA(:, 2), namesA, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axA, 'Children');
    set(handles.axA, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update the crosshair (vertical line only)
    set(handles.axA.Children(3), 'XData', [xValue, xValue]);
    
    % update the positional text
    set(handles.axA.Children(1), 'String', sprintf('z=%.1f', zValue));
    
    
    % SAGITTAL
    % update MRI slice
    set(handles.axS.Children(end), 'CData', xSlice');
    
    % update electrode positions
    locsS = locs(abs(locs(:, 1) - xValue) < handles.f.UserData.elecDist, :);
    set(handles.axS.Children(end-1), 'XData', locsS(:, 2), 'YData', locsS(:, 3));
    
    % update electrode labels
    delete(handles.axS.Children(4:end-2)); % first delete the existing labels
    namesS = electrodes.name(abs(locs(:, 1) - xValue) < handles.f.UserData.elecDist);
    nElecs = length(namesS); % how many labels are plotted
    text(handles.axS, locsS(:, 2), locsS(:, 3), namesS, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axS, 'Children');
    set(handles.axS, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    
    % update crosshair (horizontal line only)
    set(handles.axS.Children(2), 'YData', [zValue, zValue]);
    
    % update positional text
    set(handles.axS.Children(1), 'String', sprintf('x=%.1f', xValue));
    
    
    % store new x and z values for passing
    handles.f.UserData.zValue = zValue;
    handles.f.UserData.xValue = xValue;
end


% axial slice click
function btnCallbackA(~, ~, handles, bvol, x, y, z, electrodes)

    global elecNameSz

    locs = [electrodes.x, electrodes.y, electrodes.z];
    
    pt = get(gca, 'CurrentPoint');
    xCurr = pt(1, 1); yCurr = pt(1, 2); % get x and y coordinates that are clicked on axial slice
    
    % Calculate nearest exact slice x, y coordinates
    [~, xIdx] = min(abs(x - xCurr));
    xSlice = squeeze(bvol(xIdx, :, :));
    xValue = x(xIdx);
    [~, yIdx] = min(abs(y - yCurr));
    ySlice = squeeze(bvol(:, yIdx, :));
    yValue = y(yIdx);
    
    
    % Axial slice (change position of crosshair only)
    set(handles.axA.Children(3), 'XData', [xValue, xValue]); % vertical line
    set(handles.axA.Children(2), 'YData', [yValue, yValue]); % horizontal line

    
    % CORONAL
    % update MRI slice
    set(handles.axC.Children(end), 'CData', ySlice');
    
    % update electrode positions
    locsC = locs(abs(locs(:, 2) - yValue) < handles.f.UserData.elecDist, :); % plot electrodes
    set(handles.axC.Children(end-1), 'XData', locsC(:, 1), 'YData', locsC(:, 3));
    
    % update electrode labels
    delete(handles.axC.Children(4:end-2)); % first delete the existing labels
    namesC = electrodes.name(abs(locs(:, 2) - yValue) < handles.f.UserData.elecDist);
    nElecs = length(namesC); % how many labels are plotted
    text(handles.axC, locsC(:, 1), locsC(:, 3), namesC, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axC, 'Children');
    set(handles.axC, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update crosshair (vertical line only)
    set(handles.axC.Children(3), 'XData', [xValue, xValue]);
    
    % update positional text
    set(handles.axC.Children(1), 'String', sprintf('y=%.1f', yValue));
    
    
    % SAGITTAL
    % update MRI slice
    set(handles.axS.Children(end), 'CData', xSlice');
    
    % update electrode positions
    locsS = locs(abs(locs(:, 1) - xValue) < handles.f.UserData.elecDist, :);
    set(handles.axS.Children(end-1), 'XData', locsS(:, 2), 'YData', locsS(:, 3));
    
    % update electrode labels
    delete(handles.axS.Children(4:end-2)); % first delete the existing labels
    namesS = electrodes.name(abs(locs(:, 1) - xValue) < handles.f.UserData.elecDist);
    nElecs = length(namesS); % how many labels are plotted
    text(handles.axS, locsS(:, 2), locsS(:, 3), namesS, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axS, 'Children');
    set(handles.axS, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update crosshair (vertical line only)
    set(handles.axS.Children(3), 'XData', [yValue, yValue]);
    
    % update positional text
    set(handles.axS.Children(1), 'String', sprintf('x=%.1f', xValue));
    
    
    % store x and y values for passing
    handles.f.UserData.yValue = yValue;
    handles.f.UserData.xValue = xValue;
end


% sagittal slice click
function btnCallbackS(~, ~, handles, bvol, x, y, z, electrodes)

    global elecNameSz

    locs = [electrodes.x, electrodes.y, electrodes.z];
    
    pt = get(gca, 'CurrentPoint');
    yCurr = pt(1, 1); zCurr = pt(1, 2); % get y (horz) and z (vert) coordinates that are clicked on sagittal slice
    
    % Calculate nearest exact slice y, z coordinates
    [~, yIdx] = min(abs(y - yCurr));
    ySlice = squeeze(bvol(:, yIdx, :));
    yValue = y(yIdx);
    [~, zIdx] = min(abs(z - zCurr));
    zSlice = squeeze(bvol(:, :, zIdx));
    zValue = z(zIdx);
    
    
    % Sagittal slice (change position of crosshair only)
    set(handles.axS.Children(3), 'XData', [yValue, yValue]); % vertical line
    set(handles.axS.Children(2), 'YData', [zValue, zValue]); % horizontal line

    
    % CORONAL
    % update MRI slice
    set(handles.axC.Children(end), 'CData', ySlice');
    
    % update electrode positions
    locsC = locs(abs(locs(:, 2) - yValue) < handles.f.UserData.elecDist, :); % plot electrodes
    set(handles.axC.Children(end-1), 'XData', locsC(:, 1), 'YData', locsC(:, 3));
    
    % update electrode labels
    delete(handles.axC.Children(4:end-2)); % first delete the existing labels
    namesC = electrodes.name(abs(locs(:, 2) - yValue) < handles.f.UserData.elecDist);
    nElecs = length(namesC); % how many labels are plotted
    text(handles.axC, locsC(:, 1), locsC(:, 3), namesC, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axC, 'Children');
    set(handles.axC, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update crosshair (horizontal line only)
    set(handles.axC.Children(2), 'YData', [zValue, zValue]);
    
    % update positional text
    set(handles.axC.Children(1), 'String', sprintf('y=%.1f', yValue));
    
    
    % AXIAL
    % update MRI slice (last layer)
    set(handles.axA.Children(end), 'CData', zSlice');
    
    % update the electrode positions (second to last layer)
    locsA = locs(abs(locs(:, 3) - zValue) < handles.f.UserData.elecDist, :); % plot electrodes
    set(handles.axA.Children(end-1), 'XData', locsA(:, 1), 'YData', locsA(:, 2));
    
    % update electrode labels
    delete(handles.axA.Children(4:end-2)); % first delete the existing labels
    namesA = electrodes.name(abs(locs(:, 3) - zValue) < handles.f.UserData.elecDist);
    nElecs = length(namesA); % how many labels are plotted
    text(handles.axA, locsA(:, 1), locsA(:, 2), namesA, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axA, 'Children');
    set(handles.axA, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update the crosshair (horizontal line only)
    set(handles.axA.Children(2), 'YData', [yValue, yValue]);
    
    % update the positional text
    set(handles.axA.Children(1), 'String', sprintf('z=%.1f', zValue));
    
    
    % store y and z values for passing
    handles.f.UserData.yValue = yValue;
    handles.f.UserData.zValue = zValue;
end

% crosshair button callback
function btnCallbackCH(obj, ~, handles) % first input (obj) is the plot clicked (image)
    
    switch handles.f.UserData.crosshair
        case 'on'
            handles.f.UserData.crosshair = 'off';
        case 'off'
            handles.f.UserData.crosshair = 'on';
    end
    
    % update button graphic
    set(obj, 'CData', getButtonCH(handles.f.UserData.crosshair));
    
    % update visibility status of crosshairs
    set([handles.axC.Children(2:3); handles.axA.Children(2:3); handles.axS.Children(2:3)], 'Visible', handles.f.UserData.crosshair); % make crosshair visible
    
end

% elecName button callback
function btnCallbackPN(obj, ~, handles)

    switch handles.f.UserData.elecNames
        case 'on'
            handles.f.UserData.elecNames = 'off';
        case 'off'
            handles.f.UserData.elecNames = 'on';
    end
    
    % update button graphic
    set(obj, 'CData', getButtonPN(handles.f.UserData.elecNames));
    
    % update visibility status of electrode labels
    set([handles.axC.Children(4:end-2); handles.axA.Children(4:end-2); handles.axS.Children(4:end-2)], 'Visible', handles.f.UserData.elecNames);

end

function btnCallbackED(obj, ~, handles, bvol, x, y, z, electrodes, val)
% val: how much to change elecDist by

    global elecNameSz

    % change electrode distance
    if isinf(handles.f.UserData.elecDist) && sign(val) < 0 % first negative step from infinity goes to 10 mm
        handles.f.UserData.elecDist = 10;
    else % otherwise change by normal amount
        handles.f.UserData.elecDist = handles.f.UserData.elecDist + val;
    end
    
    % undo action if elecDist falls below 0
    if handles.f.UserData.elecDist < 0
        handles.f.UserData.elecDist = handles.f.UserData.elecDist - val;
        return
    elseif handles.f.UserData.elecDist > 10 % if increased above 10, go to inf
        handles.f.UserData.elecDist = inf;
    end
    
    % get locs
    locs = [electrodes.x, electrodes.y, electrodes.z];
    
    % calculate new electrodes and names within distance of slice
    locsC = locs(abs(locs(:, 2) - handles.f.UserData.yValue) < handles.f.UserData.elecDist, :);
    namesC = electrodes.name(abs(locs(:, 2) - handles.f.UserData.yValue) < handles.f.UserData.elecDist);
    locsA = locs(abs(locs(:, 3) - handles.f.UserData.zValue) < handles.f.UserData.elecDist, :);
    namesA = electrodes.name(abs(locs(:, 3) - handles.f.UserData.zValue) < handles.f.UserData.elecDist);
    locsS = locs(abs(locs(:, 1) - handles.f.UserData.xValue) < handles.f.UserData.elecDist, :);
    namesS = electrodes.name(abs(locs(:, 1) - handles.f.UserData.xValue) < handles.f.UserData.elecDist);
    
    % adjust electrode positions
    set(handles.axC.Children(end-1), 'XData', locsC(:, 1), 'YData', locsC(:, 3));
    set(handles.axA.Children(end-1), 'XData', locsA(:, 1), 'YData', locsA(:, 2));
    set(handles.axS.Children(end-1), 'XData', locsS(:, 2), 'YData', locsS(:, 3));
    
    % replot electrode labels (coronal)
    delete(handles.axC.Children(4:end-2)); % first delete the existing labels
    nElecs = length(namesC); % how many labels are plotted
    text(handles.axC, locsC(:, 1), locsC(:, 3), namesC, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackC, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axC, 'Children');
    set(handles.axC, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % replot electrode labels (axial)
    delete(handles.axA.Children(4:end-2)); % first delete the existing labels
    nElecs = length(namesA); % how many labels are plotted
    text(handles.axA, locsA(:, 1), locsA(:, 2), namesA, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackA, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axA, 'Children');
    set(handles.axA, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % replot electrode labels (sagittal)
    delete(handles.axS.Children(4:end-2)); % first delete the existing labels
    nElecs = length(namesS); % how many labels are plotted
    text(handles.axS, locsS(:, 2), locsS(:, 3), namesS, 'color', 'w', 'FontSize', elecNameSz, 'ButtonDownFcn', {@btnCallbackS, handles, bvol, x, y, z, electrodes}, 'Visible', handles.f.UserData.elecNames)
    kids = get(handles.axS, 'Children');
    set(handles.axS, 'Children', [kids(nElecs+1:nElecs+3); kids(1:nElecs); kids(end-1:end)]);
    
    % update the text in the elecDist panel
    set(handles.axED.Children(1), 'String', sprintf('%0.01f', handles.f.UserData.elecDist));

end

% Clim buttons callback
function btnCallbackClim(obj, ~, handles, ele, val)
% ele: which element in Clim (1 or 2)
% val: how much to change (e.g. 0.1 or -0.1)
    
    % change Clim value
    handles.f.UserData.clim(ele) = handles.f.UserData.clim(ele) + val;
    
    % undo action and return if clim invalid
    if handles.f.UserData.clim(2) < handles.f.UserData.clim(1)
        handles.f.UserData.clim(ele) = handles.f.UserData.clim(ele) - val;
        return
    end
    
% depress and release doesn't really work on this time scale
%     % depress button
%     switch sign(val) % positive values are up arrow, negative values are down arrow
%         case 1
%             set(obj, 'CData', getButtonArrow('on', 'up'))
%         case -1
%             set(obj, 'CData', getButtonArrow('on', 'down'))
%     end
    
    % update MRI slice Clims (surprisingly this is axis property not the image property
    set([handles.axC, handles.axA, handles.axS], 'CLim', handles.f.UserData.clim);

    % update the text in the Clim panel
    switch ele
        case 1
            set(handles.axClim.Children(2), 'String', sprintf('%0.01f', handles.f.UserData.clim(1)))
        case 2
            set(handles.axClim.Children(1), 'String', sprintf('%0.01f', handles.f.UserData.clim(2)))
    end

%     % release button
%     switch sign(val) % positive values are up arrow, negative values are down arrow
%         case 1
%             set(obj, 'CData', getButtonArrow('off', 'up'))
%         case -1
%             set(obj, 'CData', getButtonArrow('off', 'down'))
%     end
    
end

% save button callback
function btnCallbackSave(obj, ~, handles)
    
    % depress button
    set(obj, 'CData', getButtonSave('on'));

    [file, path] = uiputfile(sprintf('sliceGUI_%s.png',  datestr(now, 'yymmdd-HHMMSS')), 'Save plot as'); % default name
    
    if ischar(file)
        
        set(handles.f,'PaperPositionMode','auto'); % preserve image aspect ratio and relative sizes of electrodes, etc.
        print(handles.f, fullfile(path, file(1:end-4)), '-depsc', '-r0', '-painters'); % depsc = EPS level 3
        print(handles.f, fullfile(path, file), '-dpng', '-r0', '-painters'); % -r0 = use screen resolution
        fprintf('Plot saved as .png and .eps to %s.*\n', fullfile(path, file(1:end-4)));
                
    end
    
    % release button
    set(obj, 'CData', getButtonSave('off'));

end


%% Helper functions for design

% Crosshair button design, with shadows and red cross
function button = getButtonCH(state)

    button = getButtonGray(state);

    % add red cross
    button(12, 3:end-2, 2:3) = 0; button(3:end-2, 12, 2:3) = 0;
        
end

% elecName button design
function button = getButtonPN(state)
    
    [button, bg] = getButtonGray(state);

    % create the "NAME" text and insert into button
    raster = getLetterRaster('NAME');
    raster(raster == 0) = bg; % set to bg color
    button(10:14, 5:19, :) = repmat(raster, 1, 1, 3);
        
end

% save button design
function button = getButtonSave(state)
    
    [button, bg] = getButtonGray(state);
    
    % get SAVE text and insert into button
    raster = getSaveRaster;
    raster(raster == 0) = bg; % set to bg color
    button(5:18, 5:18, :) = repmat(raster, 1, 1, 3);
        
end

% Gray button to use as base for other buttons, return button and background color
function [button, bg] = getButtonGray(state)

    % configure colors of background, edge shadows by button state (on/off)
    switch state
        case 'on'
            bg = 0.4;
            topleft = 0.2;
            bottomright = 0.8;  
        case 'off'
            bg = 0.6;
            topleft = 0.8;
            bottomright = 0.2;
    end
    
    button = bg*ones(23, 23, 3);
    button(1, 1:end-1, :) = topleft; button(1:end-1, 1, :) = topleft;
    button(2, 1:end-2, :) = topleft; button(1:end-2, 2, :) = topleft;
    button(end, 2:end, :) = bottomright; button(2:end, end, :) = bottomright;
    button(end-1, 3:end, :) = bottomright; button(3:end, end-1, :) = bottomright;
    
end

% make arrow buttons for the Clim panel
function button = getButtonArrow(state, dir)

    % configure colors of background, edge shadows by button state (on/off)
    switch state
        case 'on'
            bg = 0.4;
            topleft = 0.2;
            bottomright = 0.8;  
        case 'off'
            bg = 0.6;
            topleft = 0.8;
            bottomright = 0.2;
    end
    
    button = bg*ones(7, 9, 3);
    button(1, 1:end-1, :) = topleft;
    button(1:end-1, 1, :) = topleft;
    button(end, 2:end, :) = bottomright; button(2:end, end, :) = bottomright;
    
    % design the arrow, insert into button
    arrow = [0, 0, 1, 0, 0;
             0, 1, 1, 1, 0;
             1, 1, 1, 1, 1];
    if strcmp(dir, 'down')  % flip upside down if direction is down
        arrow = arrow(end:-1:1, :);
    end
    arrow(arrow == 0) = bg; % set to bg color
    button(3:5, 3:7, :) = repmat(arrow, 1, 1, 3);
    
end

% creates the "NAME" text on button on elecName button, copied from labelElecNii (mnl_ieegBasics)
function raster = getLetterRaster(letters)
    
    letters = upper(letters);

    if length(letters) > 1 % rasterize each letter separately and concatenate horizontally
        raster = cat(2, [getLetterRaster(letters(1)), zeros(5, 1, 1), getLetterRaster(letters(2:end))]); % 1-pixel space in between
        return
    end
    
    switch letters
        case 'A'
            raster = [0 1 0; 1 0 1; 1 1 1; 1 0 1; 1 0 1];
        case 'E'
            raster = [1 1 1; 1 0 0; 1 1 0; 1 0 0; 1 1 1];
        case 'M'
            raster = [1 0 1; 1 1 1; 1 0 1; 1 0 1; 1 0 1];
        case 'N'
            raster = [1 1 1; 1 0 1; 1 0 1; 1 0 1; 1 0 1];
    end
    
end

% creates raster of the save icon for save button, 14 x 14
function raster = getSaveRaster()
    raster = [1 1 1 1 1 1 1      1 1 1 1 1 0 0;
              1 0 0 1 0 0 0      1 1 0 1 0 1 0;
              1 0 0 1 0 0 0      1 1 0 1 0 0 1;
              1 0 0 1 0 0 0      1 1 0 1 0 0 1;
              1 0 0 1 0 0 0      0 0 0 1 0 0 1;
              1 0 0 1 1 1 1      1 1 1 1 0 0 1;
              1 0 0 0 0 0 0      0 0 0 0 0 0 1;
              1 0 0 1 1 1 1      1 1 1 1 0 0 1; % row 8
              1 0 1 0 0 0 0      0 0 0 0 1 0 1;
              1 0 1 0 1 1 1      1 1 1 0 1 0 1;
              1 0 1 0 0 0 0      0 0 0 0 1 0 1;
              1 0 1 0 1 1 1      1 1 1 0 1 0 1;
              1 0 1 0 0 0 0      0 0 0 0 1 0 1;
              ones(1, 14)];
end

% make background for Climpanel
function bg = getClimBg
    % start with white bg
    bg = ones(21, 27, 3);
    
    % moon in center, 1 = white and 2 = black
    circ = [zeros(6, 9);
            0, 0, 0, 2, 2, 1, 0, 0, 0;
            0, 0, 2, 2, 2, 1, 1, 0, 0;
            0, 2, 2, 2, 1, 1, 1, 1, 0;
            0, 2, 2, 2, 1, 1, 1, 1, 0;
            0, 2, 2, 2, 1, 1, 1, 1, 0;
            0, 2, 2, 2, 1, 1, 1, 1, 0;
            0, 2, 2, 2, 1, 1, 1, 1, 0;
            0, 0, 2, 2, 2, 1, 1, 0, 0;
            0, 0, 0, 2, 2, 1, 0, 0, 0;
            zeros(6, 9)];
    circ(circ == 0) = 0.5;
    circ(circ == 2) = 0;
    bg(:, 10:18, :) = repmat(circ, 1, 1, 3);
    
    % borders
    bg(:, 1, :) = 0; bg(:, end, :) = 0;
    bg(1, :, :) = 0; bg(end, :, :) = 0;
    
end

% make background for Climpanel
function bg = getEDBg

    % ~2/3 gray, 1/3 white (L->R)
    bg = [0.5*ones(21, 19, 3), ones(21, 9, 3)];
    
    bg(3:19, 10, :) = 0; % black line down the middle
    bg(11, [6, 8, 12, 14], :) = 0; % dashed horizontal line
    bg(10:12, 3:4, :) = 1; bg(10:12, 16:17, :) = 1; % left and right electrodes
    
    % borders
    bg(:, 1, :) = 0; bg(1, 1:19, :) = 0; bg(end, 1:19, :) = 0;
    bg(:, end, :) = 0; % right-most border
    
end

